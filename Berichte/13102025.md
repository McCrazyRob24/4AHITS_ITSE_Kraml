# Arbeitsbericht
## Datum: 13.10.2025
## Klasse: 4AHITS
## Name: Samael Kraml

### Übung 1 - ping

## 1) IP's

- Kali:
IP: 192.168.6.52

- Metasploitable:
IP: 192.168.6.51

## 2) Pings

- Ping von Kali auf Metasploitable
![Ping von Kali auf Metasploitable](https://mccrazyrob24.github.io/4AHITS_ITSE_Kraml/Bilder/Screenshot1.png)

- Ping von Metasploitable auf Kali
![Ping von Metasploitable auf Kali](https://mccrazyrob24.github.io/4AHITS_ITSE_Kraml/Bilder/Screenshot2.png)

## 3) Kurzes Cheat‑Sheet zu `ping`‑Optionen

Eine kompakte Übersicht nützlicher `ping`‑Parameter:

* `-c <Anzahl>` — Anzahl der gesendeten ICMP‑Echo‑Requests.
* `-i <Sekunden>` — Pause zwischen aufeinanderfolgenden Paketen.
* `-t <TTL>` — Time‑to‑Live‑Wert für die Pakete.
* `-s <Größe>` — Größe der Nutzlast in Bytes.
* `-W <Sekunden>` — Wartezeit (Timeout) auf eine Antwort.
* `-4` — Nur IPv4 verwenden.
* `-6` — Nur IPv6 verwenden.
* `-q` — Quiet‑Modus; Ausgabe beschränkt sich auf die Zusammenfassung.

---

## 4) Welches Protokoll verwendet `ping`? Wie behandeln Firewalls ICMP?

Der `ping`‑Befehl verwendet ICMP (Internet Control Message Protocol), genauer ICMP‑Echo‑Requests und Echo‑Replies, um die Erreichbarkeit eines Hosts zu testen.

**Verhalten von Firewalls gegenüber ICMP:**

* Viele Firewalls blocken ICMP‑Pakete standardmäßig oder erlauben nur eingeschränkten ICMP‑Verkehr, um Netzwerkreconnaissance zu erschweren.
* Manche Umgebungen erlauben nur Pings von bestimmten Quellen oder limitieren die Rate von ICMP‑Anfragen (Rate‑Limiting).
* Deshalb kann ein Host zwar "online" sein, aber auf ICMP‑Requests nicht antworten — das bedeutet nicht zwangsläufig, dass der Dienst nicht erreichbar ist.

---

## Übung 2 - Automatisches Ping‑Skript (Subnetz‑Scan)

**Skript:**

```sh
#!/bin/bash

# Konfigurierbare Parameter
TIMEOUT=1       # Sekunden Wartezeit pro Ping
PARALLEL=50     # Anzahl paralleler Pings

# Lokale IPv4 ermitteln (erste gefundene globale Adresse)
IP=$(ip -4 addr show scope global | grep inet | awk '{print $2}' | cut -d/ -f1 | head -n1)

if [[ -z "$IP" ]]; then
  echo "Keine lokale IPv4‑Adresse gefunden. Bitte Subnetz als Parameter angeben."
  exit 1
fi

# Basisadresse für /24 extrahieren
IFS='.' read -r o1 o2 o3 o4 <<< "$IP"
BASE="$o1.$o2.$o3"

echo "Scanne Subnetz: $BASE.0/24"

ping_host() {
  TARGET="$1"
  # Einmal pingen, auf Erfolg prüfen
  if ping -c1 -W $TIMEOUT -n "$TARGET" &>/dev/null; then
    # Latenz aus der Ausgabe extrahieren
    LATENCY=$(ping -c1 -W $TIMEOUT -n "$TARGET" | grep -oP 'time=\K[0-9\.]+')
    echo "$TARGET ist aktiv (Latenz: ${LATENCY} ms)"
  fi
}

export -f ping_host
export TIMEOUT

# Hosts von .1 bis .254 parallel anpingen
seq 1 254 | xargs -P $PARALLEL -n1 -I{} bash -c 'ping_host "$BASE".{}'
```

* Das Skript ermittelt automatisch die lokale IPv4‑Adresse und scannt das zugehörige /24‑Netz.
* Mit `xargs -P` werden Pings parallel ausgeführt, damit der Scan schneller fertig ist.
* Es werden nur die aktiven Hosts ausgegeben.

Bin nicht weiter gekommen. :(
